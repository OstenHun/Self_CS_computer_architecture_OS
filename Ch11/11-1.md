<aside>

- 운영체제는 CPU를 어떻게 프로세스에 배분하는지

</aside>

## CPU 스케줄링이란?

### CPU 자원

→ 모든 프로세스는 이를 필요로 한다

### 운영체제의 개입

→ 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분한다

⇒ CPU 스케줄링 이라고 부름.

## 프로세스 우선순위

### 단순 배분

→ CPU 자원이 필요한 프로세스들의 순서대로 돌아가며 이용하게 하기

⇒ 프로세스마다 우선순위가 다르기 때문에 비효율적인 방법

### 우선순위에 따른 처리

→ 우선순위가 높은 프로세스들부터 CPU 자원을 준다.

→ e.g. 입출력 작업이 많은 프로세스 : CPU, 입출력장치 모두 사용 → 실행 상태, 대기 상태 반복하며 실행. 

## 프로세스 종류

### 입출력 집중 프로세스

→ 비디오 재생, 디스크 백업 작업 담당 프로세스 등

⇒ 입출력 작업(입출력 버스트) 이 많은 프로세스

### CPU 집중 프로세스

→ 복잡한 수학 연산, 컴파일, 그래픽 처리 작업

⇒ CPU 작업(CPU 버스트) 이 많은 프로세스

## 스케줄링 큐

### 스케줄링 큐란?

→ 프로세스들을 줄 세우기 위한 구조; 반드시 FIFO 이지 않음.

### 준비 큐

→ CPU를 이용하고 싶은 프로세스들이 서는 줄

### 대기 큐

→ 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

## 선점형과 비선점형 스케줄링

### 선점형 스케줄링

→ 프로세스가 자원을 사용하고 있더라도 OS가 프로세스로부터 자원을 강제로 뺏어서 다른 프로세스에 할당할 수 있는 방식 (앞에 나온 스케줄링 방식들)

장점: 한 프로세스의 자원 독점 막고 프로세스들에 골고루 자원 배분 가능

단점: Context Exchange 과정에서 오버헤드 발생 가능

### 비선점형 스케줄링

→ 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 (자원 사용 독점)

장점: Context Exchange 과정에서 오버헤드 적음

단점: 모든 프로세스가 골고루 자원 사용 불가.

## 마무리

### 키워드

- CPU 스케줄링
    - 공정하고 합리적으로 CPU 자원을 배분하는 방법
- 우선순위
    - 프로세스는 우선순위를 가지고 이는 PCB에 명시
- 스케줄링 큐
    - 운영체제는 효율적인 스케줄링을 위해 이를 사용
- 준비 큐
    - CPU 할당을 기다리는 프로세스들을 위한 큐
- 대기 큐
    - 입출력장치를 기다리는 프로세스들을 위한 큐
- 선점형 스케줄링
    - 프로세스가 이용 중인 자원을 뺏을 수 있음.
- 비선점형 스케줄링
    - 프로세스가 이용 중인 자원을 뺏을 수 없음.

### 확인 문제

1번 문제

선점형 스케줄링은 프로세스가 이용 중인 자원을 뺏을 수 있는 방식이다.

2번 문제

1. 준비 큐
2. 대기 큐

3번 문제

선점형 스케줄링은 문맥 교환 과정의 오버헤드가 비선점형 스케줄링에 비해 많다.

- 면접 질문
    
    ### 1. 프로세스와 스레드의 결정적인 차이
    
    ### 질문
    
    먼저, 프로세스(Process)와 스레드(Thread)의 가장 결정적인 차이점을 '자원 공유'의 관점에서 설명해 주시겠어요?
    
    ### 답변
    
    네, 가장 결정적인 차이는 '독립적인 메모리 공간의 소유 여부'입니다.
    
    프로세스는 운영체제로부터 자원을 할당받는 독립적인 실행 단위로, 자신만의 고유한 코드, 데이터, 힙, 스택 메모리 영역을 가집니다. 따라서 기본적으로 다른 프로세스와 자원을 공유하지 않습니다.
    
    반면에 스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 스레드는 자신이 속한 프로세스의 코드, 데이터, 힙 영역을 공유합니다. 하지만 실행 흐름을 독립적으로 유지하기 위해, 함수 호출 정보나 지역 변수 등을 저장하는 스택(Stack)과 프로그램 카운터(PC), 레지스터 값은 각 스레드마다 별도로 할당받습니다.
    
    ### (꼬리 질문)
    
    스레드는 왜 스택은 따로, 힙은 공유하도록 설계되었나요?
    
    ### 답변
    
    스택을 따로 할당받는 이유는 스레드가 '독립적인 실행 흐름'을 가져야 하기 때문입니다. 스택은 함수가 호출될 때의 정보(지역 변수, 매개변수, 복귀 주소)를 저장하는 공간입니다. 만약 스레드들이 스택을 공유한다면, 각자의 함수 호출 정보가 뒤섞여서 정상적인 실행이 불가능해집니다. 따라서 모든 스레드는 자신만의 실행 스택이 필요합니다.
    
    힙을 공유하는 이유는 '효율적인 협력과 통신'을 위해서입니다. 힙은 프로그래머가 동적으로 할당하는 데이터(객체, 큰 데이터 블록 등)가 저장되는 공간입니다. 스레드들이 힙을 공유함으로써, 별도의 복잡한 IPC(프로세스 간 통신) 기법 없이도 같은 데이터를 빠르고 쉽게 참조하고 수정할 수 있습니다. 이는 멀티스레딩의 핵심 이점인 '자원 공유를 통한 효율성'과 직결됩니다.
    
    ### 멀티프로세스 vs 멀티스레드 (선택의 이유)
    
    ### 질문
    
    새로운 웹 서버를 개발해야 한다고 가정해 봅시다. 멀티프로세스와 멀티스레드 방식의 장단점을 '메모리 효율성'과 '안정성' 측면에서 비교하고, 어떤 상황에서 각각 더 유리할지 설명해 주세요.
    
    ### 답변
    
    두 방식의 장단점은 명확하게 갈립니다.
    
    1. 메모리 효율성:
        - 멀티프로세스: 매우 비효율적입니다. 새로운 클라이언트 요청마다 프로세스를 생성(fork)한다면, 기존 프로세스의 모든 자원(코드, 데이터, 힙 등)이 메모리에 그대로 복제됩니다. 이는 심각한 메모리 낭비를 초래합니다.
        - 멀티스레드: 매우 효율적입니다. 새로운 요청마다 스레드를 생성하면, 스택과 레지스터 등 최소한의 실행 정보만 추가로 할당되고, 핵심 자원인 코드, 데이터, 힙은 모두 공유합니다. 따라서 훨씬 적은 메모리로 동시성을 처리할 수 있습니다.
    2. 안정성:
        - 멀티프로세스: 매우 안정적입니다. 각 프로세스는 독립된 메모리 공간을 가지므로, 하나의 프로세스(워커)에서 오류가 발생해 비정상적으로 종료되더라도, 다른 프로세스(마스터나 다른 워커)에 전혀 영향을 주지 않고 서비스 전체가 중단되는 사태를 막을 수 있습니다.
        - 멀티스레드: 불안정합니다. 모든 스레드가 메모리를 공유하기 때문에, 하나의 스레드에서 발생한 메모리 접근 오류(e.g., Null Pointer 역참조)나 처리되지 않은 예외는 프로세스 전체를 비정상적으로 종료시킬 수 있습니다. 이는 해당 프로세스 내의 모든 스레드가 함께 종료됨을 의미합니다.
    
    [상황별 선택]
    따라서, 웹 서버처럼 수많은 클라이언트의 요청을 동시에 처리해야 하고, 메모리 효율성과 스레드 간의 빠른 데이터 공유(e.g., 캐시된 데이터 접근)가 중요하다면 멀티스레드 방식이 더 유리합니다.
    
    반면, 크롬 브라우저처럼 여러 개의 탭(작업)이 서로 완벽하게 격리되어야 하고, 하나의 탭(프로세스)이 '먹통'이 되더라도 다른 탭이나 브라우저 전체에 영향을 주지 않아야 하는 안정성이 최우선인 상황이라면 멀티프로세스 방식이 더 유리합니다.